:py:mod:`dacapo.apply`
======================

.. py:module:: dacapo.apply


Module Contents
---------------


Functions
~~~~~~~~~

.. autoapisummary::

   dacapo.apply.apply
   dacapo.apply.apply_run



Attributes
~~~~~~~~~~

.. autoapisummary::

   dacapo.apply.logger


.. py:data:: logger

   

.. py:function:: apply(run_name: str, input_container: pathlib.Path | str, input_dataset: str, output_path: pathlib.Path | str, validation_dataset: Optional[dacapo.experiments.datasplits.datasets.dataset.Dataset | str] = None, criterion: str = 'voi', iteration: Optional[int] = None, parameters: Optional[dacapo.experiments.tasks.post_processors.post_processor_parameters.PostProcessorParameters | str] = None, roi: Optional[funlib.geometry.Roi | str] = None, num_workers: int = 30, output_dtype: Optional[numpy.dtype | str] = np.uint8, compute_context: dacapo.compute_context.ComputeContext = LocalTorch(), overwrite: bool = True, file_format: str = 'zarr')

   Load weights and apply a model to a dataset. If iteration is None, the best iteration based on the criterion is used. If roi is None, the whole input dataset is used.


.. py:function:: apply_run(run_name: str, iteration: int, parameters: dacapo.experiments.tasks.post_processors.post_processor_parameters.PostProcessorParameters, input_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, prediction_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, output_array_identifier: dacapo.store.array_store.LocalArrayIdentifier, roi: Optional[funlib.geometry.Roi] = None, num_workers: int = 30, output_dtype: Optional[numpy.dtype] = np.uint8, compute_context: dacapo.compute_context.ComputeContext = LocalTorch(), overwrite: bool = True)

   Apply the model to a dataset. If roi is None, the whole input dataset is used. Assumes model is already loaded.


