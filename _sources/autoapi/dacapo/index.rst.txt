:py:mod:`dacapo`
================

.. py:module:: dacapo


Subpackages
-----------
.. toctree::
   :titlesonly:
   :maxdepth: 3

   blockwise/index.rst
   compute_context/index.rst
   examples/index.rst
   experiments/index.rst
   ext/index.rst
   gp/index.rst
   store/index.rst
   utils/index.rst


Submodules
----------
.. toctree::
   :titlesonly:
   :maxdepth: 1

   apply/index.rst
   options/index.rst
   plot/index.rst
   predict/index.rst
   train/index.rst
   validate/index.rst


Package Contents
----------------

Classes
~~~~~~~

.. autoapisummary::

   dacapo.Options



Functions
~~~~~~~~~

.. autoapisummary::

   dacapo.apply
   dacapo.train
   dacapo.validate
   dacapo.predict



.. py:class:: Options


   .. py:method:: instance(**kwargs) -> DaCapoConfig
      :classmethod:


   .. py:method:: config_file() -> Optional[pathlib.Path]
      :classmethod:



.. py:function:: apply(run_name: str, input_container: pathlib.Path | str, input_dataset: str, output_path: pathlib.Path | str, validation_dataset: Optional[dacapo.experiments.datasplits.datasets.dataset.Dataset | str] = None, criterion: str = 'voi', iteration: Optional[int] = None, parameters: Optional[dacapo.experiments.tasks.post_processors.post_processor_parameters.PostProcessorParameters | str] = None, roi: Optional[funlib.geometry.Roi | str] = None, num_workers: int = 12, output_dtype: numpy.dtype | str = np.uint8, overwrite: bool = True, file_format: str = 'zarr')

   Load weights and apply a model to a dataset. If iteration is None, the best iteration based on the criterion is used. If roi is None, the whole input dataset is used.


.. py:function:: train(run_name: str)

   Train a run


.. py:function:: validate(run_name: str, iteration: int, num_workers: int = 1, output_dtype: str = 'uint8', overwrite: bool = True)

   Validate a run at a given iteration. Loads the weights from a previously
   stored checkpoint. Returns the best parameters and scores for this
   iteration.


.. py:function:: predict(run_name: str | dacapo.experiments.Run, iteration: int | None, input_container: pathlib.Path | str, input_dataset: str, output_path: dacapo.store.local_array_store.LocalArrayIdentifier | pathlib.Path | str, output_roi: Optional[funlib.geometry.Roi | str] = None, num_workers: int = 12, output_dtype: numpy.dtype | str = np.uint8, overwrite: bool = True)

   Predict with a trained model.

   :param run_name: The name of the run to predict with or the Run object.
   :type run_name: str or Run
   :param iteration: The training iteration of the model to use for prediction.
   :type iteration: int or None
   :param input_container: The container of the input array.
   :type input_container: Path | str
   :param input_dataset: The dataset name of the input array.
   :type input_dataset: str
   :param output_path: The path where the prediction array will be stored, or a LocalArryIdentifier for the prediction array.
   :type output_path: LocalArrayIdentifier | str
   :param output_roi: The ROI of the output array. If None, the ROI of the input array will be used. Defaults to None.
   :type output_roi: Optional[Roi | str], optional
   :param num_workers: The number of workers to use for blockwise prediction. Defaults to 1 for local processing, otherwise 12.
   :type num_workers: int, optional
   :param output_dtype: The dtype of the output array. Defaults to np.uint8.
   :type output_dtype: np.dtype | str, optional
   :param overwrite: If True, the output array will be overwritten if it already exists. Defaults to True.
   :type overwrite: bool, optional


